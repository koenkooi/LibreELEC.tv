From 7d719f731967df130414f93c1cec77dab38c770a Mon Sep 17 00:00:00 2001
From: Weiguang Ruan <Weiguang.ruan@amlogic.com>
Date: Mon, 17 Oct 2016 17:54:50 +0800
Subject: [PATCH 1/5] PD#119211: uart: invert cts when init

verify pass with p212 board

Change-Id: I5190a0604df2ceddf358ded9d8f0a4caf79229b0
---
 drivers/amlogic/uart/uart/meson_uart.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/amlogic/uart/uart/meson_uart.c b/drivers/amlogic/uart/uart/meson_uart.c
index 074eacb..a976f8c 100644
--- a/drivers/amlogic/uart/uart/meson_uart.c
+++ b/drivers/amlogic/uart/uart/meson_uart.c
@@ -344,6 +344,7 @@ static void meson_uart_shutdown(struct uart_port *port)
 	val = readl(port->membase + AML_UART_CONTROL);
 	val &= ~(AML_UART_RX_EN | AML_UART_TX_EN);
 	val &= ~(AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);
+	val |= (0x1 << 31);
 	writel(val, port->membase + AML_UART_CONTROL);
 
 	spin_unlock_irqrestore(&port->lock, flags);
@@ -520,6 +521,7 @@ static int meson_uart_startup(struct uart_port *port)
 	writel(val, port->membase + AML_UART_CONTROL);
 
 	val |= (AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);
+	val &= ~(0x1 << 31);
 	writel(val, port->membase + AML_UART_CONTROL);
 
 	return ret;
@@ -582,6 +584,7 @@ static void meson_uart_set_termios(struct uart_port *port,
 
 	val = readl(port->membase + AML_UART_CONTROL);
 
+
 	val &= ~AML_UART_DATA_LEN_MASK;
 	switch (cflags & CSIZE) {
 	case CS8:
@@ -620,6 +623,7 @@ static void meson_uart_set_termios(struct uart_port *port,
 		val |= AML_UART_TWO_WIRE_EN;
 
 	writel(val, port->membase + AML_UART_CONTROL);
+
 	spin_unlock_irqrestore(&port->lock, flags);
 
 	baud = uart_get_baud_rate(port, termios, old, 9600, 4000000);
@@ -692,6 +696,9 @@ static int meson_uart_request_port(struct uart_port *port)
 	val = (AML_UART_RECV_IRQ(1) | AML_UART_XMIT_IRQ(port->fifosize / 2));
 	writel(val, port->membase + AML_UART_MISC);
 
+	writel(readl(port->membase + AML_UART_CONTROL)|(1<<31),
+			port->membase + AML_UART_CONTROL);
+
 	ret = request_irq(port->irq, meson_uart_interrupt, 0,
 			  meson_uart_type(port), port);
 	return 0;

From 80eba44a48833d2ddce7e4e4b5878b825d8def31 Mon Sep 17 00:00:00 2001
From: Dezhi Kong <dezhi.kong@amlogic.com>
Date: Tue, 13 Sep 2016 19:55:56 +0800
Subject: [PATCH 2/5] PD#131854: di: fix repeat bypass di issue

Change-Id: I0d6de71535b60187cc0430b6e6466017e951fdb1
---
 drivers/amlogic/deinterlace/deinterlace.c | 18 ++++++++----------
 1 file changed, 8 insertions(+), 10 deletions(-)

diff --git a/drivers/amlogic/deinterlace/deinterlace.c b/drivers/amlogic/deinterlace/deinterlace.c
index 9cd9d6c..0eaf4cb 100644
--- a/drivers/amlogic/deinterlace/deinterlace.c
+++ b/drivers/amlogic/deinterlace/deinterlace.c
@@ -169,7 +169,7 @@ static dev_t di_devno;
 static struct class *di_clsp;
 
 #define INIT_FLAG_NOT_LOAD 0x80
-static const char version_s[] = "2016-06-17a";
+static const char version_s[] = "2016-09-13a";
 static unsigned char boot_init_flag;
 static int receiver_is_amvideo = 1;
 
@@ -6170,10 +6170,9 @@ static void inc_post_ref_count(struct di_buf_s *di_buf)
 	if (di_buf->di_buf_dup_p[1])
 		di_buf->di_buf_dup_p[1]->post_ref_count++;
 
-	if (di_buf->pulldown_mode != PULL_DOWN_BLEND_2) {
-		if (di_buf->di_buf_dup_p[0])
-			di_buf->di_buf_dup_p[0]->post_ref_count++;
-	}
+	if (di_buf->di_buf_dup_p[0])
+		di_buf->di_buf_dup_p[0]->post_ref_count++;
+
 	if (di_buf->di_buf_dup_p[2])
 		di_buf->di_buf_dup_p[2]->post_ref_count++;
 }
@@ -6192,11 +6191,10 @@ static void dec_post_ref_count(struct di_buf_s *di_buf)
 	if (di_buf->di_buf_dup_p[1])
 		di_buf->di_buf_dup_p[1]->post_ref_count--;
 
-	if (di_buf->pulldown_mode != PULL_DOWN_BLEND_2) {
-		if (di_buf->di_buf_dup_p[0] &&
-		    di_buf->di_buf_dup_p[0]->post_proc_flag != -2)
-			di_buf->di_buf_dup_p[0]->post_ref_count--;
-	}
+	if (di_buf->di_buf_dup_p[0] &&
+	    di_buf->di_buf_dup_p[0]->post_proc_flag != -2)
+		di_buf->di_buf_dup_p[0]->post_ref_count--;
+
 	if (di_buf->di_buf_dup_p[2])
 		di_buf->di_buf_dup_p[2]->post_ref_count--;
 }

From dfd4ffb14da113b148debfe434ecf0c880b537b2 Mon Sep 17 00:00:00 2001
From: KeLe Bai <kele.bai@amlogic.com>
Date: Wed, 26 Oct 2016 10:59:30 +0800
Subject: [PATCH 3/5] PD#133215: di: recycle post previous input buffer for
 bypass case

Change-Id: Ic484a70a378d27bdfc5ba0a168ced0ae60496ab4
---
 drivers/amlogic/deinterlace/deinterlace.c | 70 +++++++++++++++++++------------
 1 file changed, 44 insertions(+), 26 deletions(-)

diff --git a/drivers/amlogic/deinterlace/deinterlace.c b/drivers/amlogic/deinterlace/deinterlace.c
index 0eaf4cb..9e28011 100644
--- a/drivers/amlogic/deinterlace/deinterlace.c
+++ b/drivers/amlogic/deinterlace/deinterlace.c
@@ -2987,28 +2987,28 @@ static void log_buffer_state(unsigned char *tag)
 
 static void dump_di_buf(struct di_buf_s *di_buf)
 {
-	pr_dbg("di_buf %p vframe %p:\n", di_buf, di_buf->vframe);
-	pr_dbg("index %d, post_proc_flag %d, new_format_flag %d, type %d,",
+	pr_info("di_buf %p vframe %p:\n", di_buf, di_buf->vframe);
+	pr_info("index %d, post_proc_flag %d, new_format_flag %d, type %d,",
 		di_buf->index, di_buf->post_proc_flag,
 		di_buf->new_format_flag, di_buf->type);
-	pr_dbg("seq %d, pre_ref_count %d,post_ref_count %d, queue_index %d,",
+	pr_info("seq %d, pre_ref_count %d,post_ref_count %d, queue_index %d,",
 		di_buf->seq, di_buf->pre_ref_count, di_buf->post_ref_count,
 		di_buf->queue_index);
-	pr_dbg("pulldown_mode %d process_fun_index %d\n",
+	pr_info("pulldown_mode %d process_fun_index %d\n",
 		di_buf->pulldown_mode, di_buf->process_fun_index);
-	pr_dbg("di_buf: %p, %p, di_buf_dup_p: %p, %p, %p, %p, %p\n",
+	pr_info("di_buf: %p, %p, di_buf_dup_p: %p, %p, %p, %p, %p\n",
 		di_buf->di_buf[0], di_buf->di_buf[1], di_buf->di_buf_dup_p[0],
 		di_buf->di_buf_dup_p[1], di_buf->di_buf_dup_p[2],
 		di_buf->di_buf_dup_p[3], di_buf->di_buf_dup_p[4]);
-	pr_dbg(
+	pr_info(
 	"nr_adr 0x%lx, nr_canvas_idx 0x%x, mtn_adr 0x%lx, mtn_canvas_idx 0x%x",
 		di_buf->nr_adr, di_buf->nr_canvas_idx, di_buf->mtn_adr,
 		di_buf->mtn_canvas_idx);
 #ifdef NEW_DI_V1
-	pr_dbg("cnt_adr 0x%lx, cnt_canvas_idx 0x%x\n",
+	pr_info("cnt_adr 0x%lx, cnt_canvas_idx 0x%x\n",
 		di_buf->cnt_adr, di_buf->cnt_canvas_idx);
 #endif
-	pr_dbg("di_cnt %d, priveated %u.\n",
+	pr_info("di_cnt %d, priveated %u.\n",
 			atomic_read(&di_buf->di_cnt), di_buf->privated);
 }
 
@@ -3017,42 +3017,42 @@ static void dump_pool(int index)
 	int j;
 	queue_t *q = &queue[index];
 
-	pr_dbg("queue[%d]: in_idx %d, out_idx %d, num %d, type %d\n",
+	pr_info("queue[%d]: in_idx %d, out_idx %d, num %d, type %d\n",
 		index, q->in_idx, q->out_idx, q->num, q->type);
 	for (j = 0; j < MAX_QUEUE_POOL_SIZE; j++) {
-		pr_dbg("0x%x ", q->pool[j]);
+		pr_info("0x%x ", q->pool[j]);
 		if (((j + 1) % 16) == 0)
 			pr_debug("\n");
 	}
-	pr_debug("\n");
+	pr_info("\n");
 }
 
 static void dump_vframe(vframe_t *vf)
 {
-	pr_dbg("vframe %p:\n", vf);
-	pr_dbg("index %d, type 0x%x, type_backup 0x%x, blend_mode %d bitdepth %d\n",
+	pr_info("vframe %p:\n", vf);
+	pr_info("index %d, type 0x%x, type_backup 0x%x, blend_mode %d bitdepth %d\n",
 		vf->index, vf->type, vf->type_backup,
 		vf->blend_mode, (vf->bitdepth&BITDEPTH_Y10)?10:8);
-	pr_dbg("duration %d, duration_pulldown %d, pts %d, flag 0x%x\n",
+	pr_info("duration %d, duration_pulldown %d, pts %d, flag 0x%x\n",
 		vf->duration, vf->duration_pulldown, vf->pts, vf->flag);
-	pr_dbg("canvas0Addr 0x%x, canvas1Addr 0x%x, bufWidth %d\n",
+	pr_info("canvas0Addr 0x%x, canvas1Addr 0x%x, bufWidth %d\n",
 		vf->canvas0Addr, vf->canvas1Addr, vf->bufWidth);
-	pr_dbg("width %d, height %d, ratio_control 0x%x, orientation 0x%x\n",
+	pr_info("width %d, height %d, ratio_control 0x%x, orientation 0x%x\n",
 		vf->width, vf->height, vf->ratio_control, vf->orientation);
-	pr_dbg("source_type %d, phase %d, soruce_mode %d, sig_fmt %d\n",
+	pr_info("source_type %d, phase %d, soruce_mode %d, sig_fmt %d\n",
 		vf->source_type, vf->phase, vf->source_mode, vf->sig_fmt);
-	pr_dbg(
+	pr_info(
 		"trans_fmt 0x%x, lefteye(%d %d %d %d), righteye(%d %d %d %d)\n",
 		vf->trans_fmt, vf->left_eye.start_x, vf->left_eye.start_y,
 		vf->left_eye.width, vf->left_eye.height,
 		vf->right_eye.start_x, vf->right_eye.start_y,
 		vf->right_eye.width, vf->right_eye.height);
-	pr_dbg("mode_3d_enable %d, use_cnt %d,",
+	pr_info("mode_3d_enable %d, use_cnt %d,",
 		vf->mode_3d_enable, atomic_read(&vf->use_cnt));
-	pr_dbg("early_process_fun 0x%p, process_fun 0x%p, private_data %p\n",
+	pr_info("early_process_fun 0x%p, process_fun 0x%p, private_data %p\n",
 		vf->early_process_fun,
 		vf->process_fun, vf->private_data);
-	pr_dbg("pixel_ratio %d list %p\n",
+	pr_info("pixel_ratio %d list %p\n",
 		vf->pixel_ratio, &vf->list);
 }
 
@@ -5085,18 +5085,28 @@ static void pre_de_done_buf_config(void)
 		}
 	}
 
-	if (di_pre_stru.di_post_inp_buf) {
+	if (di_pre_stru.di_post_inp_buf && di_pre_rdma_enable) {
 		di_print("%s: %s[%d] => recycle_list\n", __func__,
-			vframe_type_name[di_pre_stru.di_inp_buf->type],
-			di_pre_stru.di_inp_buf->index);
+			vframe_type_name[di_pre_stru.di_post_inp_buf->type],
+			di_pre_stru.di_post_inp_buf->index);
 		di_lock_irqfiq_save(irq_flag2, fiq_flag);
 		queue_in(di_pre_stru.di_post_inp_buf, QUEUE_RECYCLE);
 		di_pre_stru.di_post_inp_buf = NULL;
 		di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 	}
 	if (di_pre_stru.di_inp_buf) {
-		di_pre_stru.di_post_inp_buf = di_pre_stru.di_inp_buf;
-		di_pre_stru.di_inp_buf = NULL;
+		if (!di_pre_rdma_enable) {
+			di_print("%s: %s[%d] => recycle_list\n", __func__,
+			vframe_type_name[di_pre_stru.di_inp_buf->type],
+			di_pre_stru.di_inp_buf->index);
+			di_lock_irqfiq_save(irq_flag2, fiq_flag);
+			queue_in(di_pre_stru.di_inp_buf, QUEUE_RECYCLE);
+			di_pre_stru.di_inp_buf = NULL;
+			di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
+		} else {
+			di_pre_stru.di_post_inp_buf = di_pre_stru.di_inp_buf;
+			di_pre_stru.di_inp_buf = NULL;
+		}
 	}
 }
 
@@ -5599,6 +5609,14 @@ static unsigned char pre_de_buf_config(void)
 
 			top_bot_config(di_buf);
 			queue_in(di_buf, QUEUE_PRE_READY);
+			/*if previous isn't bypass post_wr_buf not recycled */
+			if (di_pre_stru.di_post_wr_buf && di_pre_rdma_enable) {
+				queue_in(
+					di_pre_stru.di_post_inp_buf,
+					QUEUE_RECYCLE);
+				di_pre_stru.di_post_inp_buf = NULL;
+			}
+
 			if (
 				(bypass_pre & 0x2) &&
 				!di_pre_stru.cur_prog_flag)

From 30e3d1d8316292bb8ccafba5b038fd2c035edb11 Mon Sep 17 00:00:00 2001
From: Zongdong Jiao <zongdong.jiao@amlogic.com>
Date: Fri, 30 Sep 2016 13:52:15 +0800
Subject: [PATCH 4/5] PD#132331: hdmitx: optimise hdcp workflow

When init hdcp14, don't set hdcpcfg0[5], and can avoid TV blank issue.

Change-Id: Icbd17451610612815d94c8da9eada9041b441df4
---
 drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
index b644961..625aa19 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
@@ -1179,7 +1179,7 @@ static void hdcp22_hw_init(void)
 {
 	hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 7, 1);
 	hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG1, 0x7);
-	hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG0, 0x73);
+	hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG0, 0x53);
 	hd_set_reg_bits(P_HHI_GCLK_MPEG2, 1, 3, 1);
 	hd_write_reg(P_HHI_HDCP22_CLK_CNTL, 0x01000100);
 	/* Enable skpclk to HDCP2.2 IP */

From b30056ea5874f0dadcc7386a24945559d1139ed6 Mon Sep 17 00:00:00 2001
From: Linus Torvalds <torvalds@linux-foundation.org>
Date: Thu, 13 Oct 2016 13:07:36 -0700
Subject: [PATCH 5/5] mm: remove gup_flags FOLL_WRITE games from
 __get_user_pages()

commit 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619 upstream.

This is an ancient bug that was actually attempted to be fixed once
(badly) by me eleven years ago in commit 4ceb5db9757a ("Fix
get_user_pages() race for write access") but that was then undone due to
problems on s390 by commit f33ea7f404e5 ("fix get_user_pages bug").

In the meantime, the s390 situation has long been fixed, and we can now
fix it by checking the pte_dirty() bit properly (and do it better).  The
s390 dirty bit was implemented in abf09bed3cce ("s390/mm: implement
software dirty bits") which made it into v3.9.  Earlier kernels will
have to look at the page state itself.

Also, the VM has become more scalable, and what used a purely
theoretical race back then has become easier to trigger.

To fix it, we introduce a new internal FOLL_COW flag to mark the "yes,
we already did a COW" rather than play racy games with FOLL_WRITE that
is very fundamental, and then use the pte dirty flag to validate that
the FOLL_COW flag is still valid.

Change-Id: I471f87a5a403a58b7a9b11428f04093f30357e52
Reported-and-tested-by: Phil "not Paul" Oester <kernel@linuxace.com>
Acked-by: Hugh Dickins <hughd@google.com>
Reviewed-by: Michal Hocko <mhocko@suse.com>
Cc: Andy Lutomirski <luto@kernel.org>
Cc: Kees Cook <keescook@chromium.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Willy Tarreau <w@1wt.eu>
Cc: Nick Piggin <npiggin@gmail.com>
Cc: Greg Thelen <gthelen@google.com>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
[wt: s/gup.c/memory.c; s/follow_page_pte/follow_page_mask;
     s/faultin_page/__get_user_page]
Signed-off-by: Willy Tarreau <w@1wt.eu>
---
 include/linux/mm.h |  1 +
 mm/memory.c        | 14 ++++++++++++--
 2 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/include/linux/mm.h b/include/linux/mm.h
index 48bc0fe..92e35a0 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1984,6 +1984,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
 #define FOLL_HWPOISON	0x100	/* check page is hwpoisoned */
 #define FOLL_NUMA	0x200	/* force NUMA hinting page fault */
 #define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
+#define FOLL_COW	0x4000	/* internal GUP flag */
 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
diff --git a/mm/memory.c b/mm/memory.c
index a2998e9..0b985f2 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1448,6 +1448,16 @@ int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
 }
 EXPORT_SYMBOL_GPL(zap_vma_ptes);
 
+/*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+	return pte_write(pte) ||
+		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
+}
+
 /**
  * follow_page_mask - look up a page descriptor from a user-virtual address
  * @vma: vm_area_struct mapping @address
@@ -1568,7 +1578,7 @@ struct page *follow_page_mask(struct vm_area_struct *vma,
 	}
 	if ((flags & FOLL_NUMA) && pte_numa(pte))
 		goto no_page;
-	if ((flags & FOLL_WRITE) && !pte_write(pte))
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags))
 		goto unlock;
 
 	page = vm_normal_page(vma, address, pte);
@@ -1875,7 +1885,7 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 				 */
 				if ((ret & VM_FAULT_WRITE) &&
 				    !(vma->vm_flags & VM_WRITE))
-					foll_flags &= ~FOLL_WRITE;
+					foll_flags |= FOLL_COW;
 
 				cond_resched();
 			}
